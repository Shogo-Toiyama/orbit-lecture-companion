# 5. Union-Find Data Structure

The Union-Find data structure is introduced as a solution to efficiently manage a collection of disjoint sets, allowing for two primary operations: determining if two elements belong to the same set ("find") and merging two sets into one ("union"). This structure is particularly useful for algorithms like Kruskal's, where quick cycle detection is crucial.

## üìö What is the Union-Find Problem?

The Union-Find problem involves managing a collection of *disjoint sets* of elements. ‚ü¶s000942‚üß The core operations are:
*   **Find**: Given two elements, A and B, determine if they belong to the *same set*. ‚ü¶s000947, s000948, s000951, s000952‚üß For example, if 8 and 12 are in the same set, the answer is "yes"; if 7 and 6 are in different sets, the answer is "no". ‚ü¶s000949, s000950‚üß
*   **Union**: Merge two existing sets into a single, combined set. ‚ü¶s000954, s000956‚üß Once a union operation is performed, the merged sets remain as one permanently; they cannot be broken back into their original subsets. ‚ü¶s000959, s000960, s000965‚üß

These "union" and "find" operations can be performed in any order and any number of times. ‚ü¶s000969, s000971, s000977, s000978‚üß

## ‚öôÔ∏è Representing Sets with Rooted Trees

To solve the Union-Find problem, each set is represented as a *rooted tree*. ‚ü¶s000988, s000991‚üß Initially, each element starts as its own set, meaning each element is a single node that is also the root of its own tree. ‚ü¶s000990, s000991‚üß When a union operation occurs between two sets (represented by trees A and B), one tree's root is made to point to the other tree's root, effectively merging them into a single rooted tree. ‚ü¶s000993, s000994, s000995‚üß The root of a tree serves as the *name* or identifier for that entire set. ‚ü¶s001018, s001019, s001022‚üß

## üîç The "Find" Operation

To perform a *find* operation for two elements, say A and C, the process involves traversing from each element up to the root of its respective tree. ‚ü¶s000996, s000997, s001002‚üß If the roots of the two trees are the same, it means elements A and C are in the same set, and the "find" operation returns "yes". ‚ü¶s001003, s001004, s001005‚üß If the roots are different, then A and C are in different sets, and the "find" operation returns "no". ‚ü¶s001006, s001010‚üß

## ü§ù The "Union" Operation

When performing a *union* operation between two sets (represented by two rooted trees), the strategy is to attach the root of the *smaller tree* to the root of the *larger tree*. ‚ü¶s001040‚üß This approach helps to maintain the efficiency of the data structure. ‚ü¶s001042, s001043‚üß The union operation itself can be done in constant time by simply updating one pointer. ‚ü¶s001064‚üß

## üìà Maintaining Logarithmic Height

A crucial invariant for the efficiency of the Union-Find data structure is that the *height* of any rooted tree should remain *logarithmic* in the size of the set it represents. ‚ü¶s001023, s001030‚üß
*   When a smaller tree is pointed to a larger tree during a union, the height of the combined tree typically remains the same as the larger tree's height. ‚ü¶s001042, s001043‚üß
*   If two trees of the *same size* are united, the height of the combined tree will increase by one. ‚ü¶s001051, s001054, s001055‚üß However, this increase is acceptable because when two trees of size N1 are merged, the new tree has 2N1 vertices. ‚ü¶s001060‚üß Since log(2N1) equals log(N1) + 1, the height increase by one is consistent with maintaining a logarithmic height relative to the new, doubled size of the set. ‚ü¶s001061, s001062, s001063‚üß This invariant ensures that the height of any tree is always less than or equal to the logarithm of the total number of vertices, N. ‚ü¶s001032, s001034‚üß

## ‚è±Ô∏è Performance of Union-Find Operations

With the strategy of maintaining logarithmic tree heights:
*   A *find* operation takes **logarithmic time** (O(log N)), as it involves traversing from an element up to its root, and the height of the tree is logarithmic. ‚ü¶s001035, s001037, s001065‚üß
*   A *union* operation takes **constant time** (O(1)), as it only requires updating a single pointer to merge the roots of two trees. ‚ü¶s001064‚üß

## üîó Application to Kruskal's Algorithm

The Union-Find data structure is the *main data structure* used in Kruskal's algorithm for finding a Minimum Spanning Tree (MST). ‚ü¶s001076‚üß
*   In Kruskal's algorithm, edges are sorted by weight, and then processed one by one. ‚ü¶s001081‚üß
*   For each edge, the algorithm needs to determine if adding it would create a *cycle* with the edges already included in the MST. ‚ü¶s000918, s001070‚üß
*   This cycle detection is efficiently handled by Union-Find:
    *   Each connected component (or subtree) formed by the edges already added is treated as a set in the Union-Find structure. ‚ü¶s001067, s001068, s001069‚üß
    *   To check if an edge (connecting two vertices) creates a cycle, a "find" operation is performed on its two endpoints. ‚ü¶s001071‚üß
    *   If both endpoints belong to the *same set* (i.e., their roots are identical), adding the edge would create a cycle, so it is not added. ‚ü¶s001072, s001073, s001082‚üß
    *   If the endpoints belong to *different sets*, adding the edge will not create a cycle, so it is added to the MST, and a "union" operation is performed on the sets of its two endpoints to merge them into a single component. ‚ü¶s001074, s001075, s001083‚üß
*   By using Union-Find, the cycle detection for each edge takes O(log N) time, where N is the number of vertices. ‚ü¶s001077, s001078‚üß This improves the overall time complexity of Kruskal's algorithm to O(E log E), where E is the number of edges, primarily due to the initial sorting of edges and the E logarithmic-time find operations. ‚ü¶s001079‚üß Previously, a naive depth-first search for cycle detection would result in a much slower O(E¬≤) algorithm. ‚ü¶s000921, s000925, s000926‚üß