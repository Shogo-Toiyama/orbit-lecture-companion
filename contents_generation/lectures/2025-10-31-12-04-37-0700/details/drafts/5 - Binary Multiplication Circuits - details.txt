# 5. Binary Multiplication Circuits

Binary multiplication circuits are fundamental arithmetic components in digital systems, utilizing AND gates as their core one-bit multipliers. These circuits combine AND gates with adders to perform multi-bit multiplication, typically through a process of repeated addition and shifting of partial products. The efficiency of multiplication is a key metric for evaluating processor performance. ⟦s000923, s000941, s000966, s000972⟧

## Definition of Binary Multiplication
Binary multiplication is an arithmetic operation performed by combinational circuits, similar to other operations like addition, subtraction, and division. ⟦s000006⟧ This operation, when implemented in hardware, is not considered complicated. ⟦s000919⟧

## Core Principle: The AND Gate as a One-Bit Multiplier
The *AND gate* is considered the ideal component for one-bit multiplication. ⟦s000923⟧ When two binary inputs, X and Y, are processed by an AND gate, its output (XY) directly corresponds to their arithmetic product. ⟦s000924⟧ For example, the truth table for an AND gate shows:
*   0 multiplied by 0 results in 0. ⟦s000928⟧
*   0 multiplied by 1 results in 0. ⟦s000929⟧
*   1 multiplied by 0 results in 0. ⟦s000930⟧
*   1 multiplied by 1 results in 1. ⟦s000931⟧
This demonstrates that an AND gate effectively multiplies two individual bits. ⟦s000932⟧

## Mechanism for Two-Bit Binary Multiplication
To multiply two two-bit numbers, such as A (composed of bits A1A0) and B (composed of bits B1B0), the process is analogous to long multiplication in decimal. ⟦s000934⟧
1.  First, the rightmost bit of the bottom number (B0) is multiplied by each bit of the top number (A1A0), generating partial products like A0 * B0 and A1 * B0. ⟦s000936, s000937, s000938⟧
2.  Next, the process shifts one bit to the left, and the second bit of the bottom number (B1) is multiplied by each bit of the top number (A1A0), resulting in partial products like A0 * B1 and A1 * B1. ⟦s000939, s000940⟧
3.  Finally, these partial products are added together to produce the final multiplication result. ⟦s000941, s000942⟧

## Hardware Implementation for Two-Bit Multiplication
The hardware for two-bit multiplication employs AND gates for the individual bit multiplications and *half adders* for summing the partial products. ⟦s000944, s000945, s000947, s000948, s000949⟧ For instance, A0 AND B0 forms one part of the product. The result of A0 AND B1 is fed into a half adder along with A1 AND B0. ⟦s000945-s000948⟧ The carry-out from this half adder then combines with A1 AND B1 to generate further bits of the final product. ⟦s000949⟧

## Extending to Multi-Bit Binary Multiplication
For multiplying numbers with more bits, such as a 3-bit number A by a 4-bit number B, the same principles apply but require more complex arrangements of adders. ⟦s000951, s000952⟧ The rightmost bit of B (B0) is ANDed with each bit of A, and the least significant sum bit is directly passed down. ⟦s000953, s000954, s000961⟧ Subsequent partial products, generated by multiplying other bits of B with A, are effectively shifted to the left and then added using multi-bit adders. ⟦s000957, s000959, s000961⟧ In this type of implementation, if one number has N bits, N-1 adders are generally required. ⟦s000963, s000964⟧

## Practical Implementation and Performance
While direct hardware implementations using many adders are possible, multiplication in computers is typically performed through *repeated addition*. ⟦s000965, s000966, s000971⟧ This method involves storing intermediate results, shifting one of the numbers, and repeatedly adding them. ⟦s000969, s000970⟧ The speed at which a computer can perform multiplication is a critical performance metric for evaluating processors. ⟦s000972⟧ For floating-point numbers, which consist of a mantissa and an exponent, this speed is often measured in *FLOPS* (floating point operations per second), highlighting multiplication as one of the most important speed metrics. ⟦s000974, s000975, s000976, s000977, s000978⟧

## Supplement: Essential Arithmetic Circuits
*   **Half Adder:** A *half adder* is a combinational circuit designed to generate the sum of two binary digits. ⟦s000032, s000033, s000034⟧ It takes two inputs, typically labeled X and Y, and produces two outputs: a *sum* (S) and a *carry* (C). ⟦s000046⟧ The Boolean expression for the sum is X exclusive OR Y, and for the carry, it is X AND Y. ⟦s000053, s000056⟧
*   **Full Adder:** A *full adder* is also a combinational circuit, but it generates the sum of three binary bits: two input bits (X and Y) and a *carry-in* (C_in) from a previous stage. ⟦s000065, s000066, s000067⟧ It outputs a *sum* (S) and a *carry-out* (C_out). ⟦s000070⟧ The largest possible sum of three bits (1+1+1) is 3 (binary 11), which necessitates both a sum and a carry-out bit. ⟦s000068, s000069⟧ A full adder can be constructed by combining two half adders and an OR gate. ⟦s000142⟧ Multiple full adders can be chained together to create multi-bit adders, where the carry-out of one stage feeds into the carry-in of the next, a configuration known as a "ripple carry" adder. ⟦s000224, s000230, s000239, s000241⟧