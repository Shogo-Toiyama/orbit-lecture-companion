[
  {
    "sid": "s000001",
    "text": "You put in a regrade request and either your ta or the ta that created that problem will take a look at it and reply if you're not satisfied with the answer only then i ask that you only then escalate it to me and i'll be happy to take a look at it after the ta does and like always my decision that's how that's been done today we're talking about arithmetic and how we do primarily addition and subtraction we still gotta keep this class so you know an arithmetic circuit is nothing more than a combinational circuit that performs arithmetic operations such as addition subtraction multiplication and division we're going to concentrate today on addition and subtraction so we're going to develop some arithmetic circuits that use a hierarchical iterative design to beginning at the lowest level to add two binary digits and when we add two digits there really are only four possibilities we can add zero plus zero we can add zero plus one we can add one plus zero or one plus one and the yeah so zero plus zero of course is zero zero plus one is one one plus zero is one and one plus one is two zero so in the first three cases somebody's i just heard something i'm not screen sharing oh thank you let's see let me fix that bear with me your here okay good well thank you for telling me that's one thing if you're watching any of this remote i'd ask people to watch it remotely to if i missed one of these things like no sound and no here interrupt i start talking and there's nothing on the screen please interrupt i need to know that okay anyway with three of those we only need a single bit but one plus one requires two bits so if we have a circuit that adds two bits we need two outputs we need two bits of output just to handle the case of one plus one and the circuit that does that is called a half adder half adder is purely combinational it generates the sum of two bits it's got two inputs you know instead of x and y i'm going to call it x and carry cm okay and two outputs the carry and the sum which i'll call the carry the carry out cf so if we build up a little truth table for that combinational circuit can be defined with a truth table our inputs are x and the carry in nope i'm going back correctly the carry in is for the full end we'll call maximum and c and s will work i'm getting ahead of myself so x and y are the inputs and carry and sum are the outputs so with two inputs there are the four combinations and just like we did just a moment ago the first row zero plus zero an arithmetic addition not a binary or zero plus zero the sum is zero zero plus one the sum is one one plus zero the sum is one and one plus one the sum is two so if we wanted to from this i think we can eyeball this and pull out some boolean expressions for example s if we look at it see where s is a one s is a one on these two rows that is this first row is where x is a zero and y is a one so we write that not x y or in the other plate row where s is a one x is a one and y is a zero so that is x not y which is in fact exclusively x exclusively the carry is only one in one place and c is a one when both x and y are one so c is just x and y so that we can i think we can pretty easily draw the combinational circuit for that we need an exclusive or s and an and carry and the inputs to both are sin that and there's our half add that adds two bits but that's not enough you know usually when we add two bits we're really adding a much bigger number multi bit numbers and there's typically going to be a k carry in from the previous stage and that gives rise to the full adder a full adder is also a combinational circuit it generates the sum of three bits the two bits used in the half adder plus a carry so three inputs let's call them i'm going to call them xy before and here's where i want the carry carry in and then the biggest number we're going to get is going to be one plus one plus one which is three that requires two bits so we need two bits of output which will be our carry out and the sum bit so combinational circuit there's going to be eight rows on this one two three four one two three four y is zero zero one one zero zero one one zero one zero one okay so starting on the first zero plus zero plus zero that's zero and the carry out is zero the second row is zero plus zero plus one which is binary one we bring down the one and the carry is zero okay that's one the third row is the variation on the second just they're in a different order zero plus one plus zero which is one and then the fourth row row three is zero plus one plus one which is two so we bring down the zero and carry the one to give us a binary two the next row before there is one plus zero plus zero which is one we have one plus zero plus one which is two one plus one plus zero is two and the last row is all one one plus one plus one that's three bring down the one and carry it and that's the full additives so figure out what this is right let's start with s s is what are the mentions here one two four and seven and then c is what three five six and seven okay so if we write out the midterms what i want to do is some algebraic manipulation on these to see if we can i want to get them expressed using inclusive orbs so they look more like the half so let's see min term one is zero zero one right that's not x not y z min term two is zero one zero so that's not x y not zero z four is one zero zero so that's x not y not z and seven is one one one xyz okay let's see that one now the first two terms not x is common leaving not yz or y not z and on the second two terms x is common so that's x ended with not y not z or yz this is what i was looking for was x not x so not yz or y not z that's an exclusive one so that's y exclusive or z or x and this is an exclusive norm y exclusive or z naught if you take a step back and look at that okay this is actually an exclusive or of x and then this y exclusive or z term right not of the first term second not x then the true value here the true value of x ended with the not here that's an exclusive or of those two so this thing comes down to x exclusive or y excuse me to support c for c let's see min term three zero one one not x y z or minterm five one zero one x not yz min term six six is one one zero so that's x y not z and seven is xyz one one so we can do a similar type of reduction here the first two terms actually the second two terms i'm going to bring those to the front have xy being column xy ended with not z or z or and then the first two terms z is common that's not xy or x not so what this does that not z that not z or z right that's a one anything or with its complement is a one which leaves x one and then this one here is z ended with the exclusive order so here's what we got s is the exclusive or of all three terms of variables and c is slightly more complicated expression okay it's that last term xy or z ended with x squared y so we can draw a circuit that looks like that okay here's those two expressions we just came up with and this is a full adder if it implements those it's got to be the full adder which we have built by combining two half adders and an orbital so let's check this a couple different ways here's x and y coming in z comes in so this is x exclusive or y and then here's z coming in like that so we're exclusive oring z with this term so s is x exclusive or y exclusive or z and you don't need the parenthesis that matches and then for c what about here this and gate is x and y which appears on this or gate that's the xy at the beginning of the c expression and now do we get this z end with x exclusive or y what we do here's z coming into this no z right here coming into that and gate and what's on the other input is x exclusive or y when we are those two together to get z so this implements those two expressions that we derive with the algebra that said i'm always a little skeptical of these things so let's try running a few bit patterns through this just to see if it really does add three bits it should the algebra tells us it should let's put zeros on all the inputs the output should be zero zero which means we've got a zero here and here and here and here and that input on z put zeros there so coming out of this first exclusive or we get x i'm sorry variable ones actual values zero exclusive or zero is zero and now we got zero exclusive or zero which is zero so s is a zero and because that zero up here is a zero that's a zero zero and zero is zero okay coming out of this and gate right here that's got to be a right and so that makes that a zero right there zero or zero is zero sure enough s and c are zeros what i want to do now is let's make one of the bits a one we're adding zero plus zero plus one so z will be a one all the inputs and those gates inside the first half adder didn't change the signals but with z being a one we're going to put a one there and gate okay going up to that second exclusive list zero exclusive or one real difference so the s is a one and on that and gate right below it well zero and one is a zero we got zero or zero is a zero so our result is zero one so it's a binary one which is what we'd expect from zero plus zero plus one let's try changing another one of those in place the one let's think y over so now we got zero plus one plus one the output should be two you got zero and one there zero and one there so the output and let's see this is z one there and there so the output of that first exclusive or zero xor one should be a one is a one one there the output of that first and gate is zero zero and one is zero puts a zero on that last or we've got a one here so in the second exclusive or one x or one is a zero they're the same one and one is a one one or zero is a one sure enough our answer is carries a one sum's a zero we got a binary two i'll do one more i think we'll stick this one to death let's do it with all three so the output should be one line right so let's see that first we got ones on the inputs for the first two gates the z the one on z appears there and there okay one exclusive or one is a one there and the nand gate one and one is a one appears on this last arrow great the second exclusive or one xor one is made a mistake the first exclusive or one exclusive or one is a z same value of zero that's a zero that's a signal and then zero exclusive where one is a one the out and gate right below it zero and one is a zero but then with a xor gate we have zero or one which is a one so both s and c are one that's how we add three ds there's only four more combinations and they all work the same way computers typically have to add pretty large numbers right most of the desktop laptop computers we're working with now are sixty four bit processors so they need to add two they have to be able to add two sixty four bit numbers big numbers right so what we do is we combine these full adders into a chain of them so they'll handle that now let's assume let's just for simplicity sake pretend we're working with orbits and so each of these boxes with fa in the middle is that full adder we were just looking at three bits input two bits output so you can see this is full adder the zeroth bit it's adding a zero and b zero plus carry out normally be a zero the output is a sum bit and a carry drift and that carry out becomes one of the inputs to the second full adder a b and c we get a sum and a carry add the three bits we get a sum and a carry add the three bits we get a sum and a carry so what this thing does is it adds a plus b and we could potentially have five bits of output if a and b are big enough so that's why we have five we got four sum bits and a carry and this carry in is really only there because the full adder has three bits normally that would be a zero this is often called a ripple carry in the reason is we have to wait i mean if you got a lot of bits you have to wait for the carry to work its way through all the adders until the outputs are stabilized and we know what the higher order that can be slow especially if you've got a lot of bits right in a real implementation typical general purpose computer they'll do it just like this but they'll add a whole bunch of really complicated combinational logic called carry look ahead logic and they got a way of there's some tricky ways of calculating the higher order carries from the lower order carries and they project that forward and it just speeds things up a lot but the essence of how we add two numbers is this this is an atom and that's really what there is to addition which leads us to subtract yes the four bit duplicate would c zero b zero yeah normally c zero is a zero it pretty much has to be or you're going to be effectively adding one so it's four bits of a to four bits of b that's what this is now we're talking about binary which subtraction can be pretty straightforward but it becomes a problem when the subprehend is greater than the minion that is if the number on the bottom is bigger than the number on the top that means the difference is going to be negative and it's a bit more complicated to calculate if we do it as doing it by hand as people we would normally we just reverse the positions right and knowing we reverse the positions the result has to be negative we append a minus sign and we know how to borrow and all of that okay and we could do it that way in a process it requires a lot of hardware and it's pretty slow so we don't normally do it that way there's better ways to do it so as an alternative let's try doing a subtraction without regard to the relative magnitudes of the numbers so on top i'll put a number i'll call it n this is going to be one zero zero one one and we're going to subtract n which is one one one one zero so two five bit numbers and i hope it's obvious to everybody that n is bigger than n this result whatever we got here whatever we get from this is necessarily negative because we're subtracting a bigger number from a small number just do a little check what are these numbers let's see that's two three four so that first one for m is sixteen plus two plus one what's that that's nineteen right nineteen minus and the other one is sixteen plus eight which is twenty four plus four which is twenty eight plus two is thirty so the answer that we expect would be minus eleven nineteen let's see what we actually get okay let's see starting on the right one minus zero is one one minus one is zero if we get zero zero minus one we have to borrow and we can't borrow there's a zero the position to the left we go two over so if we borrow from that one that becomes a zero making one to the right one zero binary two you can borrow from that that two becomes a one making that value in column two a two so so we got two minus one one and one minus one is zero and now we've got zero minus one but there's nowhere to borrow right so what we're going to do to temporarily fix this is i'm going to add a one right here on the left i know it changes the number it's going to change the answer but it does create an opportunity to borrow so that goes to zero making that one a two we got two minus one is one what is that value that's sixteen plus four is twenty plus one that's twenty one clearly not the magnitude we were looking for we're looking for a magnitude at least even if the sign's wrong a magnitude of eleven well because a minus eleven is what minus so if we do it with five bits it's zero one zero one one that's the answer we want but if we have to borrow into the most significant position like we did we call that an end borrow we have to do an end borrow two things we know one is we know the result's negative we wouldn't have to do that in borrow if if we're going to get a positive number if the result was going to be positive they just subtract nice and easily we wouldn't have to do it in borrow but we did so we know the result's negative and we have to correct the magnitude because we change the magnitude by doing that in borrow think about what that end borrow is what we really did was add like a third number a one followed by five zeros right by putting that one to the left of the top number we added that in there so what we've calculated is m minus n plus two to the n where n is the number of digits in the original number two to the fifth this right here that's two to the fifth that's what we calculated where that two to the n is a borrow into the most significant position the magnitude we're looking for let's see we like this we calculated calculated to this we want and this is just the magnitude we want a magnitude of n minus n right remember the bigger number minus the smaller number and we know we're going to have to append a minus sign so we can get that by subtracting the number we calculated from two to the n two to the n minus m minus n plus two to the n but if you take a look and i think you'll agree that that's valid that is in fact n minus n so let's try it let's see two to the n is what a one followed by five zeros and this number that we calculated was m minus n plus two to the n and what we came up with is one zero one zero one so let's do that subtraction well by the opposite we got zero minus one so we have to borrow we gotta go way over here to borrow that one becomes a zero making the digit to the right a two borrow from there that two becomes a one the digit to the right becomes a two we borrow from there that becomes a one the digit to the right becomes a two we borrow from there which becomes a one that makes a two here you borrow from there it becomes a one and now that's two so we got two minus one is one then we got one minus zero one minus one one minus zero and one minus one is zero hey that's eleven isn't it and we know we have to append the minus sign so because the result's negative that's the number solution we're looking for so how did we get here are the steps we're going to subtract two n digit numbers m minus n binary first thing we do is we compute m minus n that's what we get if we don't have to do it in borrow then we have our answer the difference is non negative incorrect if we don't have to do it in borrow it meant the number on top is bigger we're the same but if we had to do it in borrow that would only happen if the number on the bottom is bigger then what we do well if we do it to borrow we've computed that m minus n plus two to the n then we subtract it from two to the n then append a minus sign that step three that last step is called taking the two's complement of a number so for example you've got a number that looks like this two eight bit numbers zero one one one zero zero one zero zero that's eight bits and we're going to subtract one zero zero one zero one one zero we're going to do that and the values of these i figured this out already that's one hundred and we're going to subtract one hundred fifty so the answer we expect is minus fifty you probably already guessed we're not going to get when you do the initial subtraction so what do we do here this is m and this is m so zero minus zero is zero zero minus one we have to borrow so that one over there becomes zero this two two minus one is one well zero minus one we have to borrow let's go over reposition this one that makes a two that's a one a two a one there's a two two minus one is one one minus zero is one then we got one minus one is zero zero minus zero one minus zero and zero minus one we have to do an info so we'll put a one here from which we borrow that goes to zero that becomes a two two minus one is one so i'm not going to take i'm not going to figure out what that is we know it's not a negative fifty but we need to take the two's complement of it so what we do is we're going to subtract that from two to the n right we've got this number we just calculated that this is m minus n plus two to the n and then to get the correct magnitude we need to subtract that from two to the n so two to the n is a one followed by eight zeros one two three four five six seven and eight n is the number of digits and then the number we calculated is m minus n plus two to the n if we'll write that down as one one zero zero one one one zero when we do that subtraction that should give us the correct magnitude we'll need to append a minus one so let's see zero minus zero is zero minus one well okay we've got a problem that goes to zero to two two to one to two to one to two to one to two to one to two to one two to one to two okay two minus one is one one minus one is zero one minus one is zero one minus zero is one one minus zero is one one minus one is zero one minus one is zero so this is where our position is zero one two three four five so two to the fifth is thirty two plus sixteen is forty eight yeah plus two that's fifty that's a fifty which is the magnitude we expected right and we know we need to append a minus sign so this is one one zero zero one zero to the minus ten which is minus three so that's what we did we calculated the number saw we hit do an in borrow so to fix the magnitude we subtracted it from two to the n of two to the eighth so we're going to do all this to be able to do addition and subtraction we need an adder circuit we know what that looks like and we need a subtractor circuit and a selective two's complement sometimes we have to think two's complement sometimes we don't so what we have here this is that four bit binary adder you notice we got four bits of a going in there and four four bits of b also with a subtractor four bits of a and four bits of b what's coming out of the adder is a plus b the subtractor does a minus b which may or may not be correct depending on which number is bigger if a is the larger of the two numbers or they're the same size then we will not do an end borrow and this status bit coming out of the subtractor will be a zero that signals to selective two's complementer to not do a two's complement but to pass the data straight through and we got a minus b so a plus b appears on input zero of this two to one multiplexer a minus b on input one what comes out here for the result it'll either be a sum or a difference and that depends upon what's on the select input it's a two to one mux four bits wide it only needs a single select bit and see how this is written subtractadd with an overscore that tells us if it's a one we're doing subtraction if it is a zero we're doing addition if we put a zero on s we're selecting input zero and it passes the sum through the result if we have a one on select selecting input one and we're passing the difference through the result now let's say though b is bigger than a when it runs through the subtractor we're going to have it has to do an end borrow and that sets this static which signals what this selective two's complementer does is it does another subtraction it subtracts the result coming out of the subtractor from two to the fourth the one followed by four zeros and let's do a minus sign somehow doesn't matter for our discussion right now how it does that but it gets the right column right magnitude okay and this will work but there are simpler ways to do it where we ship parts of the adder and subtractor we can make them into a common circuit it's a lot more efficient so where we're going with this is inside the computer we do something called two's complement arithmetic we represent our numbers with two's complementary so to get to that i have to explain what one's complement is then two's complement and then how we add it and review for complements right like a tens complement the way it works is the tens complement of seven is ten minus seven which is three but if you have a number with two digits right you take it ten to the second so ten's complement of seventy would be one hundred minus seventy which is thirty that's the idea of complements there's also and that's true we call it a radix complement whatever the base is you know for radix five we have a fives complement so the five complement of three is two five's complement of thirty would be fifty minus thirty is twenty and then we have something called the diminished that turns out to be mathematically important the diminished radix complement which is the base minus one so the diminished radix complement of if we're working at base five it would be the force complement so the diminished radix complement of three is one and so on so we're going to take a break in a moment and when we come back i'll get into this in more detail i do want to we got a minute or two here i want to show you something i've put in bruin learn it's not unusual for me to finish explaining all this and everybody's still stretching their hands i saw where we landed but how did you get there we look in here where it says arithmetic functions and circuits we've got some pages that addition subtraction you know this is stuff we've just been talking about but see this page called subtraction take two there are four videos in here that i found they're put on by an organization called the seso academy and i think they're really good so if you feel perplexed after this afternoon this would be time well spent to watch here they describe r's complement the diminished radix complement and then go on to representing negative numbers and subtraction using one's complement and subtraction using two's complement they're not long videos although together time adds up but anyway this is they do a very good job with that said twelve forty seven twelve forty eight let's take a ten minute break will reconvene at two last we were talking about in general not complement numbers everything we're doing here is based all we've got is ones and zeros so if we're going to talk about complement numbers it's either going to be two's complement or one's complement nothing else zero's complement makes no sense so let's first talk about one's complement for an end digit binary number the one's complement of n is it's two to the n minus one but bear in mind two to the n is a binary number that consists of a one followed by n zeros this goes i just remind everyone i think we know this this goes back if you remember that very first homework assignment i had to do you had to do a lot of funny little numbers and calculations it probably looked like busy work it wasn't remember that question i asked i gave you a it was a part a and a b i said what's the biggest number you can store with eleven bits seven bits or something like that seven bits is two to the seventh minus one it's a one two to the eighth is a one followed by eight zeros two to the eighth minus one is eight ones so keep that in mind okay so yeah for example if n equals four two to the n is two to the fourth which is a one followed by four zeros well two to the n minus one is two to the fourth minus one and that is just four ones so that's what the one's complement is right it's two to the n minus one minus the num ending small n being the number of bits so in fact what this is in parentheses here is n ones if n is eight it's eight ones if it's four it's four ones and we subtract that we subtract n from that so every bit we're subtracting from a one now which is an interesting thing to do i think we know that if we do a one minus zero that's a one and if we do a one minus one that's a zero right so notice this we're subtracting from one if we subtract a zero from one we get the complement we get a one if we subtract a one from one we get a complement we get a zero so if we subtract no matter what we do if we going bit by bit for subtracting individual bits from one they will complement for example we got a number one zero one one one zero one one zero zero one just for fun let's subtract that from one okay this is what seven bits so we're subtracting it from two to seven one minus one is zero one minus zero is one minus zero is one one minus one is zero that's zero one minus zero is one one minus one is zero you'll notice the number on the bottom bit by bit is the complement of the number and the number on the bottom is the one's complement of the number we started with because we subtracted it from two to the seventh minus one so it's that hard to calculate a one's complement you just complement every bit so if a number is say zero zero zero one one one one one's complement will be one one one zero zero zero zero because the one's complement is two to the n minus one minus the number complement every bit that's how hard one's complement is now let's talk about two's complements definition for n digit binary number n two's complement of n it's two to the n minus n when n is not zero and it's zero when n is zero that's because the result has to have n bits now let's the relationship between the two's complement and one's complement is the same especially useful there's the two's complement and i say we can get the one the two's complement by taking the ones complement and adding one so let's see here's the ones complement two to the n minus one minus n plus one i think those are equal the ones cancel and we're left with two to the n minus n so we already know how to calculate the ones complement we just complement each individual bit and this tells us this first part here this is the ones complement that the two's complement is the ones complement plus one so for example got a number here one one zero zero one one one zero that's eight bits good so first let's calculate the ones complement just complement every bit zero zero one one zero zero zero one and then we'll add one so one plus one is zero carry the one it's two one plus zero is one zero zero one one and that gives us the two's complement of that original number take the one's complement and add one that's how we get it both one's complement and two's complement have been used at various times to represent negative numbers there's a third way that's still being used and it's probably more intuitively obvious but a little more difficult to implement than a computer i'm going to call it signed binary numbers you know up till now we really haven't concerned ourselves with negative numbers everything's been a positive integer right if we want to represent negative numbers we have to at least have a sum indicate that they're negative as it turns out with both one's complement and two's complement representation that leftmost bit is a one if the value is negative it's not technically a sign bit but it's often referred to as such it means it's minimum but we can actually explicitly make that assignment right so make that high order bit assigned bit i'm going to call it n sub ho and for example if it equals zero then that indicates a positive number and if that high order bit n sub ho equals a one that would represent a negative sign so that would indicate a negative number you could do it the other way also thinking of that higher order bit as the presence or the absence of a minus sign zero and a one where a one and a zero is more intuitive so what that means is now we have to know you know everything in a computer is a string of bits right so we have to know in advance how to interpret those bits so yeah if you look at this this number zero one zero one one okay that might just be eleven maybe eleven if we're dealing with unsigned integers but it also might be a positive element there's a distinction between the two the same value that's if that's assigned integer look if we have the number one one zero one one that might be twenty seven if we're dealing with unsigned integers or it might be a negative element if that leftmost bit is a sign if we're doing it this way it's referred to as the signed magnitude system and this is used in some places it is probably the most intuitive of the representations of negative numbers it requires a fair amount of hard work so we've got this neat chart here in our textbook it shows representations of the three systems over here on the right you can see that leftmost bit the high order bit assigned bit so you got a positive one two three four for the magnitude you got four bits you can only use three for the magnitude because one of them is devoted to the sign and for a negative number that's negative and then it's a sign bit followed by the magnitude minus one two three four all the way up to minus seven when you strip off that left number leftmost bit it gives you the magnitude one's complement and two's complement are less intuitive these are referred to as sign two's complement or sign one's complement i never like using putting appending the word sign to it but in fact the leftmost bit does serve as assigned in i suppose assigned ones complement you know positive numbers are just values just like an integer except we've only got the three bits on the right available to us and for example positive one one is positive one is zero zero zero one right so the negative one must be eleven ten the one's complement sure enough there it is eleven ten the signed two's complement again there's the positive numbers and the negative numbers right the positive one is the same as we had the ones complement zero zero one the negative number with the two's complement would be the ones complement plus one which is four ones sure enough that's what you see here the one's complement and side magnitude systems present us with a little bit of difficulty because we have both a positive and a negative zero we dealt with but it's certainly inelegant the two's complement doesn't have that because it's defined it's just zero is zero and it is in fact most efficient and it's what prevails in actual eaps all these systems have been used at one time or another imagine some of them still are but two's complement is by far the most popular so if we're going to subtract using two's complement we're going to do a subtraction m minus n what we really do is we add m plus a negative n we calculate the two's complement of n and at that time m plus a negative n so we add the two's complement of n right and we get pretty much what we were doing before you get m minus n plus two to the n if m is the larger number you throw out your carry bit and you're left with m minus n it's the right answer if m is smaller than n you have to take the two's complement and put a minus sign and in actual practice it's much simpler than that if we just assume we're working in two's complement all of our numbers are two's complement the system pretty much takes care of itself so let's say x equals what have i got one zero one zero one zero zero and y seven bit numbers one followed by four zeros one one two three four one one so let's calculate x minus y and y minus x the x is the bigger number let's do that x minus two remember what you do when you're doing subtraction we're actually adding the top number plus the negative of the bottom number so we start by taking the two's complement of the bottom number going to write down y one zero zero zero zero one one and then the ones complement which is zero one one one one zero zero and then we add one to get the two's complement which is one zero one one one one zero right and this is the two's complement which is a negative one and to that we'll add x one zero one zero one zero zero we just add those let's see one plus one is two so zero carry the one one plus one plus zero is two zero carry the one one plus one plus one is three it's a one carry the one which is two zero carry one one plus zero plus one is two zero carry the one and we'll throw out then carry out and that gives us our answer which is a clearly a positive number whatever that is it's x that's x minus one so the way we did it is we figured out a negative y and then added x to it yes it does what he asked was if you take the two's complement of the number and then take the two's complement of that are you back where you started yes in fact that is i'll do that sometimes i'll wind up the negative number i know what the magnitude was and then i'll get this two's complement doesn't look like the number at all right and i can make the two's complement again just to check my magnitude yeah okay so that's x minus y right y minus x we'd expect to have a negative result right because x is bigger so let's see what's y minus x well we'll start with x which is one zero one zero one zero zero and we want to get a negative x so we need the two's complement so we start by calculating the ones complement which is just zero one zero one zero one one we not every bit and we add one okay one plus one is two so zero carry the one one plus one is two zero carry the one one plus zero is one writing down these other bits and that's a negative x that's the two's complement and to that we're going to add one which is one zero zero zero two one one zero plus one zero plus one one plus zero one plus zero zero plus zero one plus zero zero plus one carry out some zero throw that out and to the left in the seventh position on the left is a one so it's clearly a negative number that's maybe y minus x just to repeat the way you do it is you take calculate the negative or the two's complement of the number on the bottom and add it to the number on the top so what this does for us is by using the two's complement for a negative number we end up adding right we're taking the one circuit which is just complementing every bit and then after that we're doing all addition so we can eliminate that whole subtractor circuit looked at before and we can work with just an add let's see how this works here's that adder right that we looked at about an hour ago this adds four bits a plus b what if we do this i'm gonna put a not gauge on every b input which means we're adding a sub i to a complement of b sub i right it's a plus the ones complement of b and then if we make our carry in equal to one we're adding a plus the ones complement of b plus plus one effectively a plus the two's complement of b we're getting a minus b pretty clear on that this is important so i'll repeat it even if you got it i'm going to repeat it by taking the not of all the b bits we've got the ones complement of b by carrying in a one we've got the one's complement of b plus one which means the two's complement of b it's a negative v which we're adding to a this will do a minus b remember i said we wanted to combine the two circuits so the way we do that is instead of not gates we use exclusive orbs refresh your memory s and say b sub i right and i'll do a truth the for the exclusive one zero zero one one zero one one and the exclusive r looks like this so break this into two parts if s is a zero the exclusive or is the same as b sub i right but if s is a one the exclusive or is the complement of b sub i we're using the exclusive or as a selective complement complement something with a one you get i'm sorry exclusive or something with a one you get the complement exclusive or with a zero it goes through unchanged so if we were to set s equals zero what are we getting that's a zero on all these lines we got b three b three b two b two b one a one b zero a zero and deuterium is zero we're adding a plus b so if s equals a zero we're doing addition let's make s a one if s equals one that's a one that's a one that's a one that's a one so we're actually complementing now right we've got not b three not v two not v one not v zero so we're adding a to the ones complement of b and then we're adding one we're calculating a minus b this becomes a subtractor so if s is equals one we're doing subtraction and this is in fact the most common way to do this in a general purpose computer except for the ripple carry part of the carries right normally they'd add a bunch of carry look at but this is the way it's done it's pretty i think using two's complement to represent negative numbers gives us a remarkably elegant solution to this now what does this mean for you let's say there's a problem like this on the homework like we're about to do here and i will emphasize it's a very important problem it's probably the most important takeaway from today okay so we've got this little circuit the circuit here which i made very small and what we've got oh it's the part a b c and b we're given the inputs s four bits of a and four bits of b and we're asked to figure out what the outputs are five outputs right c four s three two one zero because we know what this thing does it does two's complement addition or subtraction we don't need to trace ones and zeros through the logic in fact that wouldn't even be a good idea it'd work if you did it perfectly every time but it's sort of fraught with peril easy to make a mistake there and no need to because look this first one here s equals zero meaning we're doing addition right we're just going to add a plus b zero zero one one plus zero one zero zero that's a and b one plus zero one plus zero zero plus one zero plus zero and the carry out is a zero so this represents the c four s three s two s one and s zero so we can just write those values right here i understand when we're doing this kind of arithmetic we would normally discard the carry out we've got a four bit computer you can't hold five bits you're not going to keep the four and it should be the correct result unless you got an overflow condition so but nonetheless the hardware puts it out so what this question is asking is not really what the correct arithmetic answer is it's what's the hard way over here on the right s equals one well that means we're doing subtraction so we're going to start with b put that more to the left we start with b which is zero one zero zero and then we need to figure out the ones complement not complement every bit one zero one one we'll add one to get the two's complement so one plus one is two zero carry one one plus one is two this is zero carry one one plus zero is one bring down one so there's a negative b b is clearly four right i think if you went and you looked up if you looked up at that table you'd find one one zero zero as a negative one plus one that's a zero one is zero one plus one is zero zero oh yeah that's okay okay and then we add a that's a negative b and we're going to add a which is zero zero one one and let's see we need to borrow that's a zero goes to two goes to one two two minus one is one one minus one is zero zero minus zero one minus zero and what yeah yeah i did i subtracted didn't i thank you i was thinking ahead okay then we add any which is zero zero one one so the answer is this right and that makes sense if you look at this a minus b it's three minus four we expect a negative one and it turns out in two's complement all ones is the way we represent a negative one so there's our solution there and over here you know we did a plus b three plus four we'd expect seven and that's what we've down the lower left s equals a one we're doing subtraction so we need a negative b b is zero zero one one we take the ones complement which is one one zero zero and we'll add one one that should be a negative three and we're going to add four to that a zero one zero zero one zero one plus one is two and one plus one is two zero carry the one one zero zero zero one and that's if you throw out the out to carry out you got a binary one which is the result of one minus three finally the last one s is a zero so we're just adding need plus three a is one one zero one and b is one one zero zero that's actually two negative numbers oh it's minus three and minus four so we should get a minus seven we just add those one zero one plus one is two one one plus one plus one is three and we'll carry the one if we don't actually use one one zero zero one so one zero zero one should be negative seven that's how we use this we've got subtraction take the two's complement of the bottom number and add it to the top how do you take the two's complement we complement every bit and one if it's addition s equals zero just add and this works in every case unless we have an overflow what's overflow if you've done i'm sure anybody who's done much software development at all has experienced overflow i'm sure yes wait just to confirm are a and b signed in this now we're assuming a two's complement representation for negative numbers okay that's for this to work you have to assume overflow condition means the result of your arithmetic operation has more bits has too many bits your registers you know if it's a in this case a four bit computer it needs five bits or if it's an eight bit computer it needs nine bits that's overflow and the result's inbound you don't necessarily know well there have been a lot of schemes developed to handle that both detection and correction it turns out what works best is just the detect owner we don't necessarily need to know where the problem is we just need to know it's an invalid answer and that's what you get you know when you're programming you get an exceptional condition overflow flag gets sent and in your software you handle it or if you don't typically the program will just stop running they take care of it for you right but we need to know we need to know if we got an overflow which would tell us we have an invalid result if we're working with unsigned numbers just plain old unsigned integers pretty straightforward if there's a carry out we've got an overflow and if we don't there's not but for signed numbers like two's complementary it's a bit more complicated so for example let's say we're adding two eight bit numbers so we know let's see an eight bit register eight bits we can store numbers between zero and two hundred and fifty five if we're dealing with unsigned numbers but if we're dealing with signed numbers which would include two's complement representation then an eight bit register can store the range minus one hundred and twenty eight to one hundred and twenty seven so if we got a number a result that was a positive one hundred twenty eight or a minus one hundred twenty nine we'd have an overflow it takes too many bits so let's try adding for example let's add the numbers that will give us an overflow by the way if you're adding a positive and a negative number you'll never get an overflow right because the result will be the magnitude will be less than the biggest number which presumably could already is already stored in processors in the registers you'll only get overflow if you're adding two negative numbers or adding two positive in which case you might get overflow you won't necessarily so let's add o plus ninety five and i'm working in base ten here base ten plus positive forty which gives us what one hundred and thirty five right and if this is an eight bit register that'll be an over four it's too big a number and then we'll also add a negative number base ten to a negative forty in base ten and that result of course with the a negative one hundred and thirty five also an overflow so let's see but a positive ninety five in binary is zero one zero one followed by four ones and a negative ninety five is a one zero one zero zero zero zero one positive forty five is zero zero one zero one zero zero zero and a negative forty five is one one zero one one okay so plus ninety five plus four plus a forty we're going to add these two numbers no i don't want that and you know i probably haven't launched visual studio on this computer for months so it's got to load everything the positive ninety five is zero one zero one and positive forty five well these are not forty five s they're at a zero zero one zero one zero zero that should give us a positive one hundred and thirty we're going to get one one one notice on these all the carries are zero right and then one plus one is a zero carry the one one plus one plus zero is a zero carry the one one plus zero plus one is a zero zero carry the one that's a zero carry the one one plus zero plus zero is a one will carry zero the last two carries there were different significant and then we'll do a negative ninety five plus a negative forty negative ninety five is one zero one zero zero zero four zeros and one right and negative forty is one one zero one one zero zero zero one plus zero is zero zero zero plus one zero plus one one plus zero zero plus one then one so that that's a carry that carry is a zero zero plus one plus one is two zero carry the one again the two carries are if we didn't have an overflow the last two carries would be the same because you can drop that high order bit look this is going to give us a positive number right and yet the carry out here is a zero and if we drop that high order bit if we drop the carry out our higher order bits a one which is clearly wrong it indicates a negative number the same thing here if we drop this carry out we got a zero but this has to be a negative we know it's wrong turns out if the carries are the same you're good if the last two carries are different we've got a problem it's an overflow so what we do first for an unsigned integer we just need the last carrying okay we'll call that c that's an overflow indicator for an unsigned integer but for a signed integer like two's complement we need to know if the last two carries are different or the same and an exclusive or is just about ideal for detecting right because if the inputs are different you get a one if they're the same it's a zero when we do that'll give us the last two carriers that's c three c four and this is an overflow detector we'll call it v if that's a one we've got an overflow if it's a zero we don't and those would be status those would be status bits coming out of our arithmetic logic before we use an add or subtractor like like this and all we need are those status bits which we call them flags okay we set a flag and it'd be up to the compiler interpreter needs to accommodate this and fires an interpreter stop your presumably stop your program from running and check and see if you've got something to handle okay okay good let's last thing i want to talk about is multiplication not at all complicated i can't count the number of times i've deleted that little block must be doing it on a different version i don't know okay turns out if and is like the ideal one bit multiple if you look at what an and does just this x and y and then the output is xy think about that i'll do a quick truth table there's your and function zero times zero is zero zero times one is zero one times zero is zero one times one is one it multiplies two bits that's that beautifully so say we want to multiply these two two bit numbers two digit numbers a and b right here now you do it you take the rightmost bit rightmost digit on the bottom number and multiply it through the top it's going to be a one or a zero but anyway it's going to be a zero and b zero that's a zero times b zero and then a zero and b one which is right here then we shift to the left one bit and multiply the next bottom digit to the left to the top and you get a one times b zero right here and then a one times b one once you've got that then you can do the addition bring this down you add these two carry and bring that down that's how you do it and here's the hardware to do that right here's a zero ending with the two bits of b that a zero and b zero we just bring down this a zero and b one is what we get out of here and we're running that into one side of a half adder it adds two bits and we're adding that to a one b zero which is this right here you get the carryover and carry out and that goes into a one b one and you get two bits that's the hardware to do that if you're getting a little more bits you might not use half adder you might use multi bit adders so this would be three bits of a over four bits of b a zero is coming in here and individually we and the bits with the bits of b zero the rightmost just comes straight down and then the next three bits here's how you accomplish that shift here's a one times the four bits of b they're lined up there but these three bits effectively they're a shift to the right on the we're adding in a zero so then we get the sum bring down the least significant sum bit and the next three bits go into the high order on this side times the four there and so on so the way you can do it is for every bit of if you're doing it this way for every bit of b for every bit of a you need a new adder that is if you got n bits of a you need n minus one atoms to do this so obviously this is not how we really do it when we're doing this kind of thing typically multiplication is repeated addition they might have a multiplier circuit they probably do now but then you store your results shift shift one of the words add them together multiply again store it shift it store it shift it et cetera et cetera so repeated addition this is why the rate at which a computer can multiply is such an important net speed metric when we're evaluating processes in fact we're not going to talk about it in this case to handle floating point numbers they're more complicated right they keep a mantissa and then an exponent two separate parts the what they call flops floating point operations per second they're really talking about multiplications that's one of the most important speed metrics so anyway that's it for today next week we're going to come back and we're going to get into i kind of have an idea about how it works okay no i'm saying.",
    "start": 640,
    "end": 5727660,
    "speaker": "A",
    "confidence": 0.7651367
  }
]