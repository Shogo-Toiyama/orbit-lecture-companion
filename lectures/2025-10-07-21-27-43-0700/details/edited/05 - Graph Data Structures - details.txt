# Graph Data Structures

This lecture explores how graphs are stored and organized using data structures, which is crucial for analyzing algorithm efficiency. It details two primary methods: linked list representation and matrix representation, outlining their mechanisms, examples, and trade-offs in terms of memory usage and search speed.

## Why Graph Representation Matters

Understanding how a graph is stored, or its *data structure*, is fundamental, especially when analyzing the *time complexity* of algorithms. The choice of representation directly impacts an algorithm's performance, as seen when discussing concepts like topological sort or *time complexity analysis*. Knowing these standard representations is expected for assignments and exams.

## Two Standard Ways to Represent a Graph

There are two widely recognized and standard methods for representing a graph: the **linked list representation** and the **matrix representation**. The lecture emphasizes that while many ways exist, these two are the most common and will be the focus of discussion.

## Linked List Representation of a Graph

In the **linked list representation**, each *vertex* in the graph is associated with its own *linked list*. For a graph with five vertices, such as A, B, C, D, and E, there would be five corresponding linked lists. Each list contains the vertices that the associated vertex is connected *to*. For example, if vertex A is connected to B and C, its linked list would contain B and C. It's important to note that the order of elements within a single list (e.g., B then C) does not imply a connection between B and C; it only indicates that A is connected to both B and C.

This representation is particularly important for **directed graphs**, where a connection from A to B is distinct from a connection from B to A. For instance, if A is connected to B, but B is not connected back to A, only A's list would include B. If the graph were *undirected*, B would also be connected to A. In a specific example, A connects to B and C, B connects to D, C connects to E, while D and E connect to nothing. This structure allows one to draw the graph from the lists, and vice-versa.

## Matrix Representation of a Graph

The **matrix representation** stores a graph using a matrix. The vertices of the graph (e.g., A, B, C, D, E) serve as both the rows and columns of this matrix. Each entry in the matrix is either a **0 or a 1**. A *1* indicates that an *edge* exists from the row vertex to the column vertex, while a *0* signifies that no such edge exists. The connection is always understood to be from the row to the column.

For a **directed graph**, the matrix is generally *not symmetric* because an edge from B to C does not necessarily imply an edge from C to B. However, for an **undirected graph**, the matrix becomes *symmetric*. This is because if an edge exists between B and C, it's considered the same as an edge between C and B, meaning if the entry for (B, C) is 1, the entry for (C, B) must also be 1.

## Comparing Linked List and Matrix Representations

The choice between linked list and matrix representations depends on the specific problem and graph characteristics, as each has distinct advantages and disadvantages:

*   **Memory Usage:**
    *   The **linked list representation** is generally *more compact* for graphs with a relatively small number of edges (sparse graphs). The memory used is roughly proportional to the number of edges. For example, a 10x10 matrix with only three edges would require storing 97 zeros, which is inefficient.
    *   The **matrix representation** can be *less compact* for sparse graphs because it allocates space for all possible connections, even if most don't exist. This can lead to inefficient memory use with many zero entries.

*   **Edge Existence Check:**
    *   Checking if an edge exists between two specific vertices is *slower* in the **linked list representation**. One must traverse the linked list of the starting vertex to see if the target vertex is present, which can take *linear time* relative to the number of connections from that vertex.
    *   In the **matrix representation**, checking for an edge is *very fast*, taking *constant time*. One simply accesses the corresponding entry in the matrix to immediately determine if an edge exists.

Therefore, if a graph is known to have many edges (a dense graph), the matrix representation might be preferred for its fast edge lookups. Conversely, if a graph is known to have few edges (a sparse graph), the linked list representation might be better for its memory efficiency.

## Summary of Graph Data Structures

*   Graph data structures are essential for representing how graphs are stored, influencing algorithm efficiency.
*   The two standard methods are **linked list representation** and **matrix representation**.
*   **Linked lists** store connections for each vertex in its own list, being memory-efficient for sparse graphs but slower for checking specific edges.
*   **Matrices** use a grid where entries indicate edge presence, offering fast edge checks but potentially using more memory for sparse graphs.
*   The choice of representation impacts algorithm *time complexity* and depends on the graph's density (number of edges).

## Supplement: Key Terminology

*   **Graph:** (Supplemental definition) In computer science, a graph is a non-linear data structure consisting of a finite set of *vertices* (or nodes) and a set of *edges* (or links) that connect pairs of vertices.
*   **Data Structure:** (Supplemental definition) A data structure is a particular way of organizing and storing data in a computer so that it can be accessed and modified efficiently.
*   **Vertex:** A fundamental unit of a graph, often represented as a node.
*   **Edge:** A connection between two vertices in a graph. Edges can be *directed* (one-way) or *undirected* (two-way).
*   **Topological Sort:** (Supplemental definition) An algorithm for ordering the vertices of a directed acyclic graph (DAG) such that for every directed edge from vertex U to vertex V, U comes before V in the ordering. The lecture mentions obtaining "sources" as part of this process.